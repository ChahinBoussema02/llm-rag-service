<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>LLM RAG Service — Stream UI</title>
  <style>
    body { font-family: system-ui, -apple-system, Arial; max-width: 900px; margin: 24px auto; padding: 0 12px; }
    textarea { width: 100%; height: 80px; }
    pre { white-space: pre-wrap; border: 1px solid #ddd; padding: 12px; border-radius: 8px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #eee; padding: 12px; border-radius: 10px; margin-top: 12px; }
    .muted { color: #666; }
    .err { color: #b00020; }
    input[type="password"], input[type="text"], input[type="number"] { padding: 6px 8px; }
    .grow { flex: 1; min-width: 220px; }
    code { background: #f6f6f6; padding: 2px 5px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>LLM RAG Service — Streaming Demo</h1>
  <p class="muted">Streams tokens from <code>/rag/ask/stream</code> (SSE over fetch).</p>

  <div class="card">
    <div class="row" style="margin-bottom:10px;">
      <label class="grow">
        API key
        <input id="apiKey" type="password" placeholder="Paste once (saved locally)" style="width:100%;" />
      </label>
      <label>
        <input id="showKey" type="checkbox" />
        show
      </label>
      <button id="clearKey">Clear</button>
    </div>

    <label>Question</label>
    <textarea id="q">How long do Pro users have to request a refund?</textarea>

    <div class="row">
      <label>top_k <input id="topk" type="number" value="5" min="1" max="10" /></label>
      <label>category <input id="cat" placeholder="billing (optional)"/></label>
      <label>applies_to <input id="plan" placeholder="Pro (optional)"/></label>
      <button id="go">Ask (stream)</button>
      <button id="stop">Stop</button>
      <span id="status" class="muted"></span>
    </div>
  </div>

  <div class="card">
    <h3>Answer</h3>
    <pre id="out"></pre>
  </div>

  <div class="card">
    <h3>Citations</h3>
    <pre id="cites" class="muted"></pre>
  </div>

<script>
let aborter = null;

const KEY_STORAGE = "RAG_API_KEY";
const apiKeyInput = document.getElementById("apiKey");
const showKey = document.getElementById("showKey");
const clearKeyBtn = document.getElementById("clearKey");

function stopStream() {
  if (aborter) {
    aborter.abort();
    aborter = null;
  }
  document.getElementById("status").textContent = "";
}

document.getElementById("stop").onclick = stopStream;

// ---- API key persistence ----
apiKeyInput.value = localStorage.getItem(KEY_STORAGE) || "";

apiKeyInput.addEventListener("input", () => {
  localStorage.setItem(KEY_STORAGE, apiKeyInput.value.trim());
});

showKey.addEventListener("change", () => {
  apiKeyInput.type = showKey.checked ? "text" : "password";
});

clearKeyBtn.addEventListener("click", () => {
  localStorage.removeItem(KEY_STORAGE);
  apiKeyInput.value = "";
});

// ---- SSE parsing helpers ----
function parseSseFrames(buf) {
  const normalized = buf.replace(/\r\n/g, "\n");
  const parts = normalized.split("\n\n");
  const rest = parts.pop() || "";
  return { frames: parts, rest };
}

function parseFrame(frame) {
  const lines = frame.split("\n").filter(Boolean);
  let eventName = "message";
  const dataLines = [];

  for (const ln of lines) {
    if (ln.startsWith("event:")) {
      eventName = ln.slice(6).trim();
    } else if (ln.startsWith("data:")) {
      let d = ln.slice(5);
      if (d.startsWith(" ")) d = d.slice(1);
      dataLines.push(d);
    }
  }
  return { eventName, data: dataLines.join("\n") };
}

document.getElementById("go").onclick = async () => {
  stopStream();

  const out = document.getElementById("out");
  const cites = document.getElementById("cites");
  const status = document.getElementById("status");

  out.textContent = "";
  cites.textContent = "";
  status.textContent = "Starting…";
  status.className = "muted";

  const payload = {
    question: document.getElementById("q").value,
    top_k: Number(document.getElementById("topk").value || 5),
    category: document.getElementById("cat").value || null,
    applies_to: document.getElementById("plan").value || null
  };

  const apiKey = (apiKeyInput.value || "").trim();
  if (!apiKey) {
    status.textContent = "Missing API key. Paste it above (saved locally).";
    status.className = "err";
    return;
  }

  aborter = new AbortController();

  let resp;
  try {
    resp = await fetch("/rag/ask/stream", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/event-stream",
        "Cache-Control": "no-cache",
        "X-API-Key": apiKey
      },
      body: JSON.stringify(payload),
      signal: aborter.signal
    });
  } catch (e) {
    status.textContent = "Request failed (network).";
    status.className = "err";
    return;
  }

  if (!resp.ok) {
    const text = await resp.text().catch(() => "");
    if (resp.status === 401) {
      status.textContent = "401 Unauthorized — API key missing or incorrect.";
      status.className = "err";
      out.textContent = text || "Unauthorized.";
      return;
    }
    status.textContent = `HTTP ${resp.status} ${resp.statusText}`;
    status.className = "err";
    out.textContent = text || "No response body.";
    return;
  }

  if (!resp.body) {
    status.textContent = "No response body (streaming not supported?).";
    status.className = "err";
    return;
  }

  status.textContent = "Streaming… (click Stop to abort)";
  status.className = "muted";

  const reader = resp.body.getReader();
  const dec = new TextDecoder("utf-8");
  let buf = "";

  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      buf += dec.decode(value, { stream: true });

      const { frames, rest } = parseSseFrames(buf);
      buf = rest;

      for (const frame of frames) {
        const { eventName, data } = parseFrame(frame);

        if (eventName === "meta") {
          try {
            const m = JSON.parse(data);
            cites.textContent = JSON.stringify(m.citations || [], null, 2);
          } catch (e) {
            cites.textContent = data;
          }
        } else if (eventName === "token") {
          out.textContent += data; // preserve whitespace
        } else if (eventName === "done") {
          status.textContent = "Done.";
          stopStream();
          return;
        }
      }
    }

    status.textContent = "Stream closed.";
  } catch (e) {
    if (aborter === null) return; // stopped intentionally
    status.textContent = "Stream error.";
    status.className = "err";
  } finally {
    stopStream();
  }
};
</script>
</body>
</html>